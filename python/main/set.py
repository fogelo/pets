""" 
set - наборе, неупорядоченная коллекция(множество) уникальных элементов

В Python в наборах (sets) и словарях (dictionaries) есть особенность: значение True эквивалентно 1, а False эквивалентно 0.
Поэтому, если в наборе (set) присутствует 1, то True не добавляется как отдельное значение, так как они считаются одинаковыми.

Чтобы понять методы нужно смотреть на наборы как на множества.
"""

my_set = {1, 2, 3, "apple", True}

#@ Обычные методы

my_set_copy = my_set.copy() # cоздает поверхностнюу копию
my_set.update({3,4,5}) # обновляет набор, добавляя в него элементы из другого, мутирует
my_set.add(6) # добавляет элемент в набор, мутирует
my_set.remove(6) # удаляет элемент из списка, если элемента не окажется будет ошибка, мутирует
my_set.discard(7) # удаляет элемент из списка, если элемента не окажется НЕ будет ошибки, мутирует

my_set_union = my_set.union({8,9},{1, 10}) # возвращает новый набор, который содержит все уникальные элементы из переданных наборов

my_set_difference = my_set.difference({8,9},{1, 10}) # возвращает новый набор, в котором отсутствуют элементы из переданных наборов. Аналогичен использованию оператору "-"
my_set.difference_update({8,9},{1, 10}) # мутирует набор, удаляя элементы из переданных наборов
my_set.symmetric_difference({8,9},{1, 10}) # возвращает новый набор, в котором отсутствуют элементы, которые входят во все переданные наборы,но зато присутствует все остальные из всех наборов
my_set.symmetric_difference_update({8,9},{1, 10}) # мутирует исходный набор, оставляя элементы, которые входят во все переданные наборы,но зато присутствует все остальные из всех наборов

my_set_intersection = my_set.intersection({1,2}, {3,5}) # пересечение, возвращает новый набор, в котором присутствуют элементы, входящие во все наборы
my_set.intersection_updatea({1,2}, {3,5}) # пересечение, мутирует набор, оставляя в нем только элементы, входящие в него и в остальные наборы

is_subset = my_set.issubset({1,23}) # проверяет является ли одно множество подмножеством другого
is_superset = my_set.issuperset({1,44}) # проверяет является ли одно множество надмножеством другого
is_disjoint = my_set.isdisjoint({1,65}) # проверяет имеют ли два множества общие элементы

my_set.clear() # удаляет элементы из множества, мутирует

print(my_set_difference)



#@ Магические методы

""" 
Аналоги магических методов:
1)  Пересечение 
    __and__, &, intersection

    Пересечение с обновлением исходного набора (in-place and)
    __iand__, &=, intersection_update 

    Пересечение (обратный порядок аргументов, reversed and)
    __rand__, &

2)  Объединение
    __or__, |, union

    Объединение c обновлением исходного набора (in-place or)
    __ior__, |=, update 

    Объединение (обратный порядок аргументов)
    __ror__, |


3)  Разность (subtract)
    __sub__, difference, - 

    Разность с обновлением исходного набора (in-place subtract)
    __isub__, -=, difference_update

    Разность(обратный порядок аргументов, reversed subtract)
    __rsub__, -

    
4)  Симметрическая разность (exclusive or)
    __xor__, ^,symmetric_difference   

    Cимметрическая разность с обновлением исходного набора (in-place xor)
    __ixor__, ^=, symmetric_difference_update
    
    Симметрическая разность (обратный порядок аргументов, )
    __rxor__, ^



5) Проверка на наличие элемента (содержится в...)
    __contains__, in

6) Проверка на равенство (equal)
    __eq__, ==

7) Проверка на неравенство (not equal)
    __ne__, !=, 
    
8) Проверка на надмножество (greater than or equal)
     __ge__, >=, issuperset

9) Проверка на строгое надмножество (greater than)
    __gt__, >

10) Проверка на подмножество (less than or equal)
    __le__, <=, issubset

11) Проверка на строгое подмножество (less than)
    __lt__, <, 

    
Магический метод __ror__ позволяет обеспечить правильную работу оператора | в ситуациях, когда левый операнд не 
поддерживает объединение с правым операндом, но правый операнд может обработать эту операцию. Это позволяет 
создавать более гибкие и совместимые классы в Python. Справедливо и для остальных методов: __rand__, __rsub__, __rxor__
"""

#__iter__ - используется автоматически при итерации
set1 = {1, 2, 3}
for elem in set1:
    print(elem)  # Output: 1, 2, 3 (в любом порядке)


#__len__ - получуние длины
set1 = {1, 2, 3}
print(len(set1))  # Output: 3

#__reduce__
#__reduce_ex__
#__repr__
#__sizeof__
#__str__
