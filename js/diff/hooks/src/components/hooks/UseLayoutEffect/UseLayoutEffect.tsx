/* 

useEffect - это синхронизация. Реактивные значения - это значения, которые могут меняться при повторном рендеринге и которые нужно поэтому указывать в зависимостях 
эффекта.

Эффекты в отличие от обработчиков событий реактивны. Это значит, что они повторно вызываются,когда изменяются значению указанные в зависимостях.
Зависимости должны включать каждое реактивное значение, которое вы читаете в эффекте.


Чем же отличается useEffect от useLayoutEffect? 

useEffect работает по следующему сценарию - сначала на основе return создается виртуальное дерево, затем оно отдается на отрисовку в браузер
и только затем вызывается каллбек переданный в useEffect, и после этого деревео заново строится (если был вызван setState).


чтобы увидеть разницу в этом примере нужно замедлить процессор на x6

рендер - это не отрисовака браузера, а это вызов компонента реактом и построение virtual dom

useEffect - рендер(построение VDOM)>отрисовка браузером>вызов каллбека в useEffect>рендер>отрисовка браузером 
useLayoutEffect - рендер>вызов каллбека в useEffect>рендер>отрисовка браузером



Жизненный цикл эффектов отличается от жизненного цикла компонентов. Компоненты могут монтироваться, обновляться и размонтироваться. Эффект 
может делать только 2 вещи: начинать синхронизацию чего либо, а позже прекращать синхронизацию чего-либо.

Полезно думать о useEffect как о синхронизации, а компонентах думать как-будто у них есть жизненный цикл вмонтровать, обновиться, удалиться

*/

import { useEffect, useLayoutEffect, useRef, useState } from "react";

const UseLayoutEffect = () => {
  const [width, setWidth] = useState(0);
  const ref = useRef(null);

  useLayoutEffect(() => {
    let i = 0;

    while (i < 200000000) {
      i++;
    }

    setWidth(ref.current.clientWidth);
  }, []);

  return (
    <div
      ref={ref}
      style={{ width: 100, height: 100, background: "green", color: "white" }}
    >
      width: {width}
    </div>
  );
};

export default UseLayoutEffect;
